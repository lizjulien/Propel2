<?php

/**
 * This file is part of the Propel package.
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @license    MIT License
 */

namespace Propel\Generator\Builder\Om;

use Propel\Generator\Model\Column;
use Propel\Generator\Model\IdMethod;
use Propel\Generator\Model\Validator;
use Propel\Generator\Platform\PlatformInterface;

/**
 * Generates the PHP5 table map class for user object model (OM).
 *
 * @author     Hans Lellelid <hans@xmpl.org>
 */
class TableMapBuilder extends AbstractOMBuilder
{
    /**
     * Gets the package for the map builder classes.
     * @return     string
     */
    public function getPackage()
    {
        return parent::getPackage() . '.Map';
    }

    public function getNamespace()
    {
        if ($namespace = parent::getNamespace()) {
            if ($this->getGeneratorConfig() && $omns = $this->getGeneratorConfig()->getBuildProperty('namespaceMap')) {
                return $namespace . '\\' . $omns;
            } else {
                return $namespace;
            }
        }
    }

    /**
     * Returns the name of the current class being built.
     * @return     string
     */
    public function getUnprefixedClassname()
    {
        return $this->getTable()->getPhpName() . 'TableMap';
    }

    /**
     * Adds class phpdoc comment and openning of class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addClassOpen(&$script)
    {
        $table = $this->getTable();
        $script .= "

/**
 * This class defines the structure of the '".$table->getName()."' table.
 *";
        if ($this->getBuildProperty('addTimeStamp')) {
            $now = strftime('%c');
            $script .= "
 * This class was autogenerated by Propel " . $this->getBuildProperty('version') . " on:
 *
 * $now
 *";
        }
        $script .= "
 */
class ".$this->getClassname()." extends TableMap
{
";
    }

    /**
     * Specifies the methods that are added as part of the map builder class.
     * This can be overridden by subclasses that wish to add more methods.
     * @see        ObjectBuilder::addClassBody()
     */
    protected function addClassBody(&$script)
    {
        $table = $this->getTable();

        $this->declareClasses(
            '\Propel\Runtime\Map\TableMap',
            '\Propel\Runtime\Map\RelationMap'
        );

        $this->addConstants($script);

        if (!$table->isAlias()) {
            $this->addConstantsAndAttributes($script);
        }

        $this->addInstanceAttribute($script);
        $this->addAttributes($script);

        $this->addInstanceGetter($script);

        $this->addTranslateFieldName($script);
        $this->addGetFieldNames($script);

        if ($table->hasEnumColumns()) {
            $this->addGetValueSets($script);
            $this->addGetValueSet($script);
        }

        $this->addInitialize($script);
        $this->addBuildRelations($script);
        $this->addGetBehaviors($script);

        $this->addBuildTableMap($script);
    }

    /**
     * Adds any constants needed for this TableMap class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addConstants(&$script)
    {
        $script .= "
    /**
     * The (dot-path) name of this class
     */
    const CLASS_NAME = '".$this->getClasspath()."';
";
    }

    /**
     * Adds any attributes needed for this TableMap class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addAttributes(&$script)
    {
    }

    /**
     * Closes class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addClassClose(&$script)
    {
        $script .= "
} // " . $this->getClassname() . "
";
        $this->addStaticTableMapRegistration($script);
    }

    /**
     * Adds the addInitialize() method to the  table map class.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addInitialize(&$script)
    {
        $table = $this->getTable();
        $platform = $this->getPlatform();

        $this->declareClass('\Propel\Runtime\Exception\PropelException');

        $script .= "
    /**
     * Initialize the table attributes, columns and validators
     * Relations are not initialized by this method since they are lazy loaded
     *
     * @return     void
     * @throws     PropelException
     */
    public function initialize()
    {
        // attributes
        \$this->setName('".$table->getName()."');
        \$this->setPhpName('".$table->getPhpName()."');
        \$this->setClassname('" . addslashes($this->getStubObjectBuilder()->getFullyQualifiedClassname()) . "');
        \$this->setPackage('" . parent::getPackage() . "');";
        if ($table->getIdMethod() == "native") {
            $script .= "
        \$this->setUseIdGenerator(true);";
        } else {
            $script .= "
        \$this->setUseIdGenerator(false);";
        }

        if ($table->getIdMethodParameters()) {
            $params = $table->getIdMethodParameters();
            $imp = $params[0];
            $script .= "
        \$this->setPrimaryKeyMethodInfo('".$imp->getValue()."');";
        } elseif ($table->getIdMethod() == IdMethod::NATIVE && ($platform->getNativeIdMethod() == PlatformInterface::SEQUENCE || $platform->getNativeIdMethod() == PlatformInterface::SERIAL)) {
            $script .= "
        \$this->setPrimaryKeyMethodInfo('".$platform->getSequenceName($table)."');";
        }

        if ($this->getTable()->getChildrenColumn()) {
            $script .= "
        \$this->setSingleTableInheritance(true);";
        }

        if ($this->getTable()->getIsCrossRef()) {
            $script .= "
        \$this->setIsCrossRef(true);";
        }

        // Add columns to map
            $script .= "
        // columns";
        foreach ($table->getColumns() as $col) {
            $cup=strtoupper($col->getName());
            $cfc=$col->getPhpName();
            if (!$col->getSize()) {
                $size = "null";
            } else {
                $size = $col->getSize();
            }
            $default = $col->getDefaultValueString();
            if ($col->isPrimaryKey()) {
                if ($col->isForeignKey()) {
                    foreach ($col->getForeignKeys() as $fk) {
                        $script .= "
        \$this->addForeignPrimaryKey('$cup', '$cfc', '".$col->getType()."' , '".$fk->getForeignTableName()."', '".strtoupper($fk->getMappedForeignColumn($col->getName()))."', ".($col->isNotNull() ? 'true' : 'false').", ".$size.", $default);";
                    }
                } else {
                    $script .= "
        \$this->addPrimaryKey('$cup', '$cfc', '".$col->getType()."', ".var_export($col->isNotNull(), true).", ".$size.", $default);";
                }
            } else {
                if ($col->isForeignKey()) {
                    foreach ($col->getForeignKeys() as $fk) {
                        $script .= "
        \$this->addForeignKey('$cup', '$cfc', '".$col->getType()."', '".$fk->getForeignTableName()."', '".strtoupper($fk->getMappedForeignColumn($col->getName()))."', ".($col->isNotNull() ? 'true' : 'false').", ".$size.", $default);";
                    }
                } else {
                    $script .= "
        \$this->addColumn('$cup', '$cfc', '".$col->getType()."', ".var_export($col->isNotNull(), true).", ".$size.", $default);";
                }
            } // if col-is prim key
            if ($col->isEnumType()) {
                $script .= "
        \$this->getColumn('$cup', false)->setValueSet(" . var_export($col->getValueSet(), true). ");";
            }
            if ($col->isPrimaryString()) {
                $script .= "
        \$this->getColumn('$cup', false)->setPrimaryString(true);";
            }
        } // foreach

        // validators
        $script .= "
        // validators";
        foreach ($table->getValidators() as $val) {
            $col = $val->getColumn();
            $cup = strtoupper($col->getName());
            foreach ($val->getRules() as $rule) {
                if ($val->getTranslate() !== Validator::TRANSLATE_NONE) {
                    $script .= "
        \$this->addValidator('$cup', '".$rule->getName()."', '".$rule->getClass()."', '".str_replace("'", "\'", $rule->getValue())."', ".$val->getTranslate()."('".str_replace("'", "\'", $rule->getMessage())."'));";
                } else {
                    $script .= "
        \$this->addValidator('$cup', '".$rule->getName()."', '".$rule->getClass()."', '".str_replace("'", "\'", $rule->getValue())."', '".str_replace("'", "\'", $rule->getMessage())."');";
                } // if ($rule->getTranslation() ...
                } // foreach rule
        }  // foreach validator

        $script .= "
    } // initialize()
";

    }

    /**
     * Adds the method that build the RelationMap objects
     * @param      string &$script The script will be modified in this method.
     */
    protected function addBuildRelations(&$script)
    {
        $script .= "
    /**
     * Build the RelationMap objects for this table relationships
     */
    public function buildRelations()
    {";
        foreach ($this->getTable()->getForeignKeys() as $fkey) {
            $columnMapping = 'array(';
            foreach ($fkey->getLocalForeignMapping() as $key => $value) {
                $columnMapping .= "'$key' => '$value', ";
            }
            $columnMapping .= ')';
            $onDelete = $fkey->hasOnDelete() ? "'" . $fkey->getOnDelete() . "'" : 'null';
            $onUpdate = $fkey->hasOnUpdate() ? "'" . $fkey->getOnUpdate() . "'" : 'null';
            $script .= "
        \$this->addRelation('" . $this->getFKPhpNameAffix($fkey) . "', '" . addslashes($this->getNewStubObjectBuilder($fkey->getForeignTable())->getFullyQualifiedClassname()) . "', RelationMap::MANY_TO_ONE, $columnMapping, $onDelete, $onUpdate);";
        }
        foreach ($this->getTable()->getReferrers() as $fkey) {
            $relationName = $this->getRefFKPhpNameAffix($fkey);
            $columnMapping = 'array(';
            foreach ($fkey->getForeignLocalMapping() as $key => $value) {
                $columnMapping .= "'$key' => '$value', ";
            }
            $columnMapping .= ')';
            $onDelete = $fkey->hasOnDelete() ? "'" . $fkey->getOnDelete() . "'" : 'null';
            $onUpdate = $fkey->hasOnUpdate() ? "'" . $fkey->getOnUpdate() . "'" : 'null';
            $script .= "
        \$this->addRelation('$relationName', '" . addslashes($this->getNewStubObjectBuilder($fkey->getTable())->getFullyQualifiedClassname()) . "', RelationMap::ONE_TO_" . ($fkey->isLocalPrimaryKey() ? "ONE" : "MANY") .", $columnMapping, $onDelete, $onUpdate";
            if ($fkey->isLocalPrimaryKey()) {
                 $script .= ");";
            } else {
                $script .= ", '" . $this->getRefFKPhpNameAffix($fkey, true) . "');";
            }
        }
        foreach ($this->getTable()->getCrossFks() as $fkList) {
            list(, $crossFK) = $fkList;
            $relationName = $this->getFKPhpNameAffix($crossFK);
            $pluralName = "'" . $this->getFKPhpNameAffix($crossFK, true) . "'";
            $onDelete = $fkey->hasOnDelete() ? "'" . $fkey->getOnDelete() . "'" : 'null';
            $onUpdate = $fkey->hasOnUpdate() ? "'" . $fkey->getOnUpdate() . "'" : 'null';
            $script .= "
        \$this->addRelation('$relationName', '" . addslashes($this->getNewStubObjectBuilder($crossFK->getForeignTable())->getFullyQualifiedClassname()) . "', RelationMap::MANY_TO_MANY, array(), $onDelete, $onUpdate, $pluralName);";
        }
        $script .= "
    } // buildRelations()
";
    }

    /**
     * Adds the behaviors getter
     * @param      string &$script The script will be modified in this method.
     */
    protected function addGetBehaviors(&$script)
    {
        if ($behaviors = $this->getTable()->getBehaviors()) {
            $script .= "
    /**
     *
     * Gets the list of behaviors registered for this table
     *
     * @return array Associative array (name => parameters) of behaviors
     */
    public function getBehaviors()
    {
        return array(";
            foreach ($behaviors as $behavior) {
                $script .= "
            '{$behavior->getName()}' => array(";
                foreach ($behavior->getParameters() as $key => $value) {
                    $script .= "'$key' => '$value', ";
                }
                $script .= "),";
            }
            $script .= "
        );
    } // getBehaviors()
";
        }
    }

    /**
     * Checks whether any registered behavior on that table has a modifier for a hook
     * @param string $hookName The name of the hook as called from one of this class methods, e.g. "preSave"
     * @return boolean
     */
    public function hasBehaviorModifier($hookName, $modifier = null)
    {
        return parent::hasBehaviorModifier($hookName, 'TableMapBuilderModifier');
    }

    /**
     * Checks whether any registered behavior on that table has a modifier for a hook
     * @param string $hookName The name of the hook as called from one of this class methods, e.g. "preSave"
     * @param string &$script The script will be modified in this method.
     */
    public function applyBehaviorModifier($hookName, &$script, $tab = "        ")
    {
        return $this->applyBehaviorModifierBase($hookName, 'TableMapBuilderModifier', $script, $tab);
    }

    /**
     * Adds constant and variable declarations that go at the top of the class.
     * @param      string &$script The script will be modified in this method.
     * @see        addColumnNameConstants()
     */
    protected function addConstantsAndAttributes(&$script)
    {
        $dbName = $this->getDatabase()->getName();
        $tableName = $this->getTable()->getName();
        $tablePhpName = $this->getTable()->isAbstract() ? '' : addslashes($this->getStubObjectBuilder()->getFullyQualifiedClassname());
        $script .= "
    /** the default database name for this class */
    const DATABASE_NAME = '$dbName';

    /** the table name for this class */
    const TABLE_NAME = '$tableName';

    /** the related Propel class for this table */
    const OM_CLASS = '$tablePhpName';

    /** A class that can be returned by this peer. */
    const CLASS_DEFAULT = '".$this->getStubObjectBuilder()->getClasspath()."';

    /** The total number of columns. */
    const NUM_COLUMNS = ".$this->getTable()->getNumColumns().";

    /** The number of lazy-loaded columns. */
    const NUM_LAZY_LOAD_COLUMNS = ".$this->getTable()->getNumLazyLoadColumns().";

    /** The number of columns to hydrate (NUM_COLUMNS - NUM_LAZY_LOAD_COLUMNS) */
    const NUM_HYDRATE_COLUMNS = ". ($this->getTable()->getNumColumns() - $this->getTable()->getNumLazyLoadColumns()) .";
";
        $this->addColumnNameConstants($script);
        $this->addInheritanceColumnConstants($script);
        if ($this->getTable()->hasEnumColumns()) {
            $this->addEnumColumnConstants($script);
        }

        $script .= "
    /** The default string format for model objects of the related table **/
    const DEFAULT_STRING_FORMAT = '" . $this->getTable()->getDefaultStringFormat() . "';

    /**
     * An identiy map to hold any loaded instances of ".$this->getObjectClassname()." objects.
     * This must be public so that other peer classes can access this when hydrating from JOIN
     * queries.
     * @var        array ".$this->getObjectClassname()."[]
     */
    static public \$instances = array();

";

        // apply behaviors
        $this->applyBehaviorModifier('staticConstants', $script, "    ");
        $this->applyBehaviorModifier('staticAttributes', $script, "    ");

        $this->addFieldNamesAttribute($script);
        $this->addFieldKeysAttribute($script);

        if ($this->getTable()->hasEnumColumns()) {
            $this->addEnumColumnAttributes($script);
        }
    }

    /**
     * Adds the COLUMN_NAME contants to the class definition.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addColumnNameConstants(&$script)
    {
        foreach ($this->getTable()->getColumns() as $col) {
            $script .= "
    /** the column name for the " . strtoupper($col->getName()) ." field */
    const ".$this->getColumnName($col) ." = '" . $this->getTable()->getName() . ".".strtoupper($col->getName())."';
";
        } // foreach
    }

    /**
     * Adds the valueSet constants for ENUM columns.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addEnumColumnConstants(&$script)
    {
        foreach ($this->getTable()->getColumns() as $col) {
            if ($col->isEnumType()) {
                $script .= "
    /** The enumerated values for the " . strtoupper($col->getName()) . " field */";
                foreach ($col->getValueSet() as $value) {
                    $script .= "
    const " . $this->getColumnName($col) . '_' . $this->getEnumValueConstant($value) . " = '" . $value . "';";
                }
                $script .= "
";
            }
        }
    }

    protected function getEnumValueConstant($value)
    {
        return strtoupper(preg_replace('/[^a-zA-Z0-9_\x7f-\xff]/', '_', $value));
    }

    protected function addFieldNamesAttribute(&$script)
    {
        $table = $this->getTable();

        $tableColumns = $table->getColumns();

        $script .= "
    /**
     * holds an array of fieldnames
     *
     * first dimension keys are the type constants
     * e.g. self::\$fieldNames[self::TYPE_PHPNAME][0] = 'Id'
     */
    protected static \$fieldNames = array (
        TableMap::TYPE_PHPNAME => array (";
        foreach ($tableColumns as $col) {
            $script .= "'".$col->getPhpName()."', ";
        }
        $script .= "),
        TableMap::TYPE_STUDLYPHPNAME => array (";
        foreach ($tableColumns as $col) {
            $script .= "'".$col->getStudlyPhpName()."', ";
        }
        $script .= "),
        TableMap::TYPE_COLNAME => array (";
        foreach ($tableColumns as $col) {
            $script .= $this->getColumnConstant($col, 'self').", ";
        }
        $script .= "),
        TableMap::TYPE_RAW_COLNAME => array (";
        foreach ($tableColumns as $col) {
            $script .= "'" . $col->getConstantColumnName() . "', ";
        }
        $script .= "),
        TableMap::TYPE_FIELDNAME => array (";
        foreach ($tableColumns as $col) {
            $script .= "'".$col->getName()."', ";
        }
        $script .= "),
        TableMap::TYPE_NUM => array (";
        foreach ($tableColumns as $num => $col) {
            $script .= "$num, ";
        }
        $script .= ")
    );
";
    }

    protected function addFieldKeysAttribute(&$script)
    {
        $table = $this->getTable();

        $tableColumns = $table->getColumns();

        $script .= "
    /**
     * holds an array of keys for quick access to the fieldnames array
     *
     * first dimension keys are the type constants
     * e.g. self::\$fieldNames[TableMap::TYPE_PHPNAME]['Id'] = 0
     */
    protected static \$fieldKeys = array (
        TableMap::TYPE_PHPNAME => array (";
        foreach ($tableColumns as $num => $col) {
            $script .= "'".$col->getPhpName()."' => $num, ";
        }
        $script .= "),
        TableMap::TYPE_STUDLYPHPNAME => array (";
        foreach ($tableColumns as $num => $col) {
            $script .= "'".$col->getStudlyPhpName()."' => $num, ";
        }
        $script .= "),
        TableMap::TYPE_COLNAME => array (";
        foreach ($tableColumns as $num => $col) {
            $script .= $this->getColumnConstant($col, 'self')." => $num, ";
        }
        $script .= "),
        TableMap::TYPE_RAW_COLNAME => array (";
        foreach ($tableColumns as $num => $col) {
            $script .= "'" . $col->getConstantColumnName() . "' => $num, ";
        }
        $script .= "),
        TableMap::TYPE_FIELDNAME => array (";
        foreach ($tableColumns as $num => $col) {
            $script .= "'".$col->getName()."' => $num, ";
        }
        $script .= "),
        TableMap::TYPE_NUM => array (";
        foreach ($tableColumns as $num => $col) {
            $script .= "$num, ";
        }
        $script .= ")
    );
";
    } // addFielKeysAttribute

    /**
     * Adds the valueSet attributes for ENUM columns.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addEnumColumnAttributes(&$script)
    {
        $script .= "
    /** The enumerated values for this table */
    protected static \$enumValueSets = array(";
        foreach ($this->getTable()->getColumns() as $col) {
            if ($col->isEnumType()) {
                $script .= "
        self::" . $this->getColumnName($col) ." => array(
";
                foreach ($col->getValueSet() as $value) {
                    $script .= "            " . $this->getStubPeerBuilder()->getClassname() . '::' . $this->getColumnName($col) . '_' . $this->getEnumValueConstant($value) . ",
";
                }
                $script .= "        ),";
            }
        }
        $script .= "
    );
";
    }

    protected function addInstanceAttribute(&$script)
    {
        $script .= "
    /**
     * @var {$this->getFullyQualifiedClassname()}
     */
    static private \$instance = null;
";
    }

    protected function addInstanceGetter(&$script)
    {
        $script .= "
    static public function getInstance()
    {
        if (null === self::\$instance) {
            self::\$instance = new self();
        }

        return self::\$instance;
    }
";
    }

    protected function addGetFieldNames(&$script)
    {
        $this->declareClass('\Propel\Runtime\Exception\PropelException');

        $script .= "
    /**
     * Returns an array of field names.
     *
     * @param      string \$type The type of fieldnames to return:
     *                      One of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_STUDLYPHPNAME
     *                      TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM
     * @return     array A list of field names
     */

    static public function getFieldNames(\$type = TableMap::TYPE_PHPNAME)
    {
        if (!array_key_exists(\$type, self::\$fieldNames)) {
            throw new PropelException('Method getFieldNames() expects the parameter \$type to be one of the class constants TableMap::TYPE_PHPNAME, TableMap::TYPE_STUDLYPHPNAME, TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM. ' . \$type . ' was given.');
        }

        return self::\$fieldNames[\$type];
    }
";

    } // addGetFieldNames()

    protected function addTranslateFieldName(&$script)
    {
        $this->declareClass('\Propel\Runtime\Exception\PropelException');

        $script .= "
    /**
     * Translates a fieldname to another type
     *
     * @param      string \$name field name
     * @param      string \$fromType One of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_STUDLYPHPNAME
     *                         TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM
     * @param      string \$toType   One of the class type constants
     * @return     string translated name of the field.
     * @throws     PropelException - if the specified name could not be found in the fieldname mappings.
     */
    static public function translateFieldName(\$name, \$fromType, \$toType)
    {
        \$toNames = self::getFieldNames(\$toType);
        \$key = isset(self::\$fieldKeys[\$fromType][\$name]) ? self::\$fieldKeys[\$fromType][\$name] : null;
        if (\$key === null) {
            throw new PropelException(\"'\$name' could not be found in the field names of type '\$fromType'. These are: \" . print_r(self::\$fieldKeys[\$fromType], true));
        }

        return \$toNames[\$key];
    }
";
    } // addTranslateFieldName()

    /**
     * Adds the getValueSets() method.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addGetValueSets(&$script)
    {
        $this->declareClassFromBuilder($this->getTableMapBuilder());
        $callingClass = $this->getStubPeerBuilder()->getClassname();
        $script .= "
    /**
     * Gets the list of values for all ENUM columns
     * @return array
     */
    static public function getValueSets()
    {
      return {$callingClass}::\$enumValueSets;
    }
";
    }

    /**
     * Adds the getValueSet() method.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addGetValueSet(&$script)
    {
        $this->declareClassFromBuilder($this->getTableMapBuilder());
        $script .= "
    /**
     * Gets the list of values for an ENUM column
     * @return array list of possible values for the column
     */
    static public function getValueSet(\$colname)
    {
        \$valueSets = self::getValueSets();

        return \$valueSets[\$colname];
    }
";
    }

    /**
     * Adds the CLASSKEY_* and CLASSNAME_* constants used for inheritance.
     * @param      string &$script The script will be modified in this method.
     */
    public function addInheritanceColumnConstants(&$script)
    {
        if (!$col = $this->getTable()->getChildrenColumn()) {
            return;
        }

        if (!$col->isEnumeratedClasses()) {
            return;
        }

        foreach ($col->getChildren() as $child) {
            $childBuilder = $this->getMultiExtendObjectBuilder();
            $childBuilder->setChild($child);
            $fqcn = addslashes($childBuilder->getFullyQualifiedClassname());

            $script .= "
    /** A key representing a particular subclass */
    const CLASSKEY_".strtoupper($child->getKey())." = '" . $child->getKey() . "';
";

            if (strtoupper($child->getClassname()) != strtoupper($child->getKey())) {
                $script .= "
    /** A key representing a particular subclass */
    const CLASSKEY_".strtoupper($child->getClassname())." = '" . $child->getKey() . "';
";
            }

            $script .= "
    /** A class that can be returned by this peer. */
    const CLASSNAME_".strtoupper($child->getKey())." = '". $fqcn . "';
";
        }
    }

    public function getColumnName(Column $col, $phpName = null)
    {
        // was it overridden in schema.xml ?
        if ($col->getPeerName()) {
            $const = strtoupper($col->getPeerName());
        } else {
            $const = strtoupper($col->getName());
        }

        if (null !== $phpName) {
            return sprintf('%sTableMap::$s', $phpName, $const);
        }

        return $const;
    }

    /**
     * Adds the static map builder registration code.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addStaticTableMapRegistration(&$script)
    {
        $script .= "
// This is the static code needed to register the TableMap for this table with the main Propel class.
//
".$this->getClassName()."::buildTableMap();

";
$this->applyBehaviorModifier('tableMapFilter', $script, '');
    }

    /**
     * Adds the buildTableMap() method.
     * @param      string &$script The script will be modified in this method.
     */
    protected function addBuildTableMap(&$script)
    {
        $this->declareClass('\Propel\Runtime\Propel');
        $this->declareClassFromBuilder($this->getTableMapBuilder());

        $script .= "
    /**
     * Add a TableMap instance to the database for this peer class.
     */
    static public function buildTableMap()
    {
      \$dbMap = Propel::getServiceContainer()->getDatabaseMap(".$this->getClassname()."::DATABASE_NAME);
      if (!\$dbMap->hasTable(".$this->getClassname()."::TABLE_NAME))
      {
        \$dbMap->addTableObject(new ".$this->getClassname()."());
      }
    }
";
    }
}
